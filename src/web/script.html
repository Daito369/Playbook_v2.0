<script>
/**
 * PolicyPlayBook v2.0 - Frontend JavaScript
 * Main application logic and API integration
 */

// Global application state
const AppState = {
  workflowId: null,
  currentStep: 1,
  totalSteps: 5,
  workflowType: null,
  selectedPolicy: {
    category: null,
    subcategory: null
  },
  selectedStatus: null,
  templateData: null,
  formData: {},
  generatedContent: null,
  settings: {
    defaultMyName: '',
    defaultOpening: '0',
    enableAutoSave: true,
    enableSounds: false
  }
};

// API configuration
const API_BASE = '';
const REQUEST_TIMEOUT = 30000; // 30 seconds

// Initialize application
document.addEventListener('DOMContentLoaded', function() {
  console.log('PolicyPlayBook v2.0 initializing...');
  initializeApp();
});

/**
 * Initialize the application
 */
async function initializeApp() {
  try {
    showLoading();
    
    // Load user settings
    await loadSettings();
    
    // Display user info
    await loadUserInfo();
    
    // Initialize workflow
    await initializeWorkflow();
    
    hideLoading();
    showStepContent();
    
    console.log('Application initialized successfully');
  } catch (error) {
    console.error('Application initialization failed:', error);
    showError('¢◊Í±¸∑ÁÛnk1WW~W_: ' + error.message);
    hideLoading();
  }
}

/**
 * Initialize workflow
 */
async function initializeWorkflow() {
  try {
    const response = await apiCall('workflow/initialize', {
      locale: 'ja-JP'
    });
    
    if (response.success) {
      AppState.workflowId = response.data.workflowId;
      AppState.totalSteps = response.data.totalSteps;
      
      // Load workflow types
      loadWorkflowTypes(response.data.availableTypes);
      
      // Update step indicator
      updateStepIndicator(1);
      
      console.log('Workflow initialized:', AppState.workflowId);
    } else {
      throw new Error(response.error || 'Workflow initialization failed');
    }
  } catch (error) {
    console.error('Workflow initialization error:', error);
    throw error;
  }
}

/**
 * Load workflow types and display cards
 */
function loadWorkflowTypes(types) {
  const container = document.getElementById('workflowTypeCards');
  container.innerHTML = '';
  
  types.forEach(type => {
    const cardHtml = `
      <div class="col-md-6 col-lg-3">
        <div class="workflow-type-card" data-type="${type.id}" onclick="selectWorkflowType('${type.id}')">
          <div class="card-icon">
            <i class="${type.icon}"></i>
          </div>
          <div class="card-title">${type.label}</div>
          <div class="card-description">
            ${getWorkflowTypeDescription(type.id)}
          </div>
        </div>
      </div>
    `;
    container.insertAdjacentHTML('beforeend', cardHtml);
  });
}

/**
 * Get workflow type description
 */
function getWorkflowTypeDescription(typeId) {
  const descriptions = {
    'misreview': '§c_È˚PúnÓc',
    'disapproval': '›Í∑¸UÕkàãç',
    'certification': 'çö3ÀnÊ',
    'other': ']n÷n˛‹'
  };
  return descriptions[typeId] || '';
}

/**
 * Select workflow type
 */
async function selectWorkflowType(typeId) {
  try {
    // Visual feedback
    document.querySelectorAll('.workflow-type-card').forEach(card => {
      card.classList.remove('selected');
    });
    document.querySelector(`[data-type="${typeId}"]`).classList.add('selected');
    
    AppState.workflowType = typeId;
    
    // Load policies for this workflow type
    await loadPolicies(typeId);
    
    // Move to next step
    nextStep();
    
    showSuccess('Ô¸Ø’Ì¸ø§◊LxûUå~W_');
  } catch (error) {
    console.error('Workflow type selection error:', error);
    showError('Ô¸Ø’Ì¸ø§◊nxûk1WW~W_');
  }
}

/**
 * Load policies for selected workflow type
 */
async function loadPolicies(workflowType) {
  try {
    const response = await apiCall('workflow/policies', {
      type: workflowType
    });
    
    if (response.success) {
      const categories = response.data.categories;
      populatePolicySelectors(categories);
    } else {
      throw new Error(response.error || 'Failed to load policies');
    }
  } catch (error) {
    console.error('Policy loading error:', error);
    throw error;
  }
}

/**
 * Populate policy selector dropdowns
 */
function populatePolicySelectors(categories) {
  const mainCategorySelect = document.getElementById('mainCategory');
  mainCategorySelect.innerHTML = '<option value="">xûWfO`UD</option>';
  
  categories.forEach(category => {
    const option = document.createElement('option');
    option.value = category.name;
    option.textContent = category.name;
    option.dataset.subcategories = JSON.stringify(category.subcategories);
    mainCategorySelect.appendChild(option);
  });
  
  AppState.policyCategories = categories;
}

/**
 * Load subcategories when main category is selected
 */
function loadSubcategories() {
  const mainCategorySelect = document.getElementById('mainCategory');
  const subCategorySelect = document.getElementById('subCategory');
  const selectedOption = mainCategorySelect.options[mainCategorySelect.selectedIndex];
  
  // Clear subcategory selection
  subCategorySelect.innerHTML = '<option value="">xûWfO`UD</option>';
  subCategorySelect.disabled = true;
  document.getElementById('step2NextButton').disabled = true;
  
  if (selectedOption.value) {
    const subcategories = JSON.parse(selectedOption.dataset.subcategories || '[]');
    
    subcategories.forEach(subcategory => {
      const option = document.createElement('option');
      option.value = subcategory.name;
      option.textContent = subcategory.name;
      subCategorySelect.appendChild(option);
    });
    
    subCategorySelect.disabled = false;
    AppState.selectedPolicy.category = selectedOption.value;
  } else {
    AppState.selectedPolicy.category = null;
  }
  
  AppState.selectedPolicy.subcategory = null;
  hidePolicyPreview();
}

/**
 * Handle subcategory change
 */
function onSubcategoryChange() {
  const subCategorySelect = document.getElementById('subCategory');
  const step2NextButton = document.getElementById('step2NextButton');
  
  if (subCategorySelect.value) {
    AppState.selectedPolicy.subcategory = subCategorySelect.value;
    showPolicyPreview();
    step2NextButton.disabled = false;
  } else {
    AppState.selectedPolicy.subcategory = null;
    hidePolicyPreview();
    step2NextButton.disabled = true;
  }
}

/**
 * Show policy preview
 */
function showPolicyPreview() {
  const preview = document.getElementById('policyPreview');
  const previewText = document.getElementById('policyPreviewText');
  
  previewText.textContent = `${AppState.selectedPolicy.category} > ${AppState.selectedPolicy.subcategory}`;
  preview.style.display = 'block';
}

/**
 * Hide policy preview
 */
function hidePolicyPreview() {
  const preview = document.getElementById('policyPreview');
  preview.style.display = 'none';
}

/**
 * Load available statuses for current workflow type
 */
async function loadAvailableStatuses() {
  try {
    // Get available statuses based on workflow type
    const statuses = getStatusesByWorkflowType(AppState.workflowType);
    displayStatusCards(statuses);
  } catch (error) {
    console.error('Status loading error:', error);
    showError('∂Kn≠ºk1WW~W_');
  }
}

/**
 * Get statuses by workflow type
 */
function getStatusesByWorkflowType(workflowType) {
  const statusMap = {
    'misreview': [
      { value: 'approved', label: 'ç', description: '§È˚kàäçk	Ù' }
    ],
    'disapproval': [
      { value: 'disapproval_with_response', label: 'çÈ˚ËrKâﬁTBä	', description: 'È˚ËrKâwSÑjﬁTLBã4' },
      { value: 'disapproval_inferred', label: 'ç®,	', description: '®,k˙eOçn4' }
    ],
    'certification': [
      { value: 'approved', label: 'ç', description: 'çö3ÀLçUå_4' },
      { value: 'disapproved', label: 'ç', description: 'çö3ÀLçn4' }
    ],
    'other': [
      { value: 'need_info', label: ']n÷Need info	', description: '˝†≈1L≈Åj4' },
      { value: 'at_followmail', label: 'AT/followmail', description: '’©Ì¸¢√◊·¸În4' },
      { value: 'forced_stop', label: '76\b', description: '76\bn4' }
    ]
  };
  
  return statusMap[workflowType] || [];
}

/**
 * Display status cards
 */
function displayStatusCards(statuses) {
  const container = document.getElementById('statusCards');
  container.innerHTML = '';
  
  statuses.forEach(status => {
    const cardHtml = `
      <div class="col-md-6">
        <div class="status-card" data-status="${status.value}" onclick="selectStatus('${status.value}')">
          <div class="status-title">${status.label}</div>
          <div class="status-description">${status.description}</div>
        </div>
      </div>
    `;
    container.insertAdjacentHTML('beforeend', cardHtml);
  });
}

/**
 * Select status
 */
async function selectStatus(statusValue) {
  try {
    // Visual feedback
    document.querySelectorAll('.status-card').forEach(card => {
      card.classList.remove('selected');
    });
    document.querySelector(`[data-status="${statusValue}"]`).classList.add('selected');
    
    AppState.selectedStatus = statusValue;
    document.getElementById('step3NextButton').disabled = false;
    
    showSuccess('∂KLxûUå~W_');
  } catch (error) {
    console.error('Status selection error:', error);
    showError('∂Knxûk1WW~W_');
  }
}

/**
 * Load template for current selections
 */
async function loadTemplate() {
  try {
    showFormLoading();
    
    const response = await apiCall('workflow/template', {
      workflowType: AppState.workflowType,
      category: AppState.selectedPolicy.category,
      subcategory: AppState.selectedPolicy.subcategory,
      status: AppState.selectedStatus
    });
    
    if (response.success) {
      AppState.templateData = response.data;
      displayTemplateForm(response.data);
      updateLivePreview();
    } else {
      throw new Error(response.error || 'Template not found');
    }
  } catch (error) {
    console.error('Template loading error:', error);
    showError('∆Û◊Ï¸»n≠ºk1WW~W_');
  } finally {
    hideFormLoading();
  }
}

/**
 * Display template form
 */
function displayTemplateForm(templateData) {
  const container = document.getElementById('formFields');
  container.innerHTML = '';
  
  // Combine required and optional fields
  const allFields = [
    ...templateData.requiredFields.map(field => ({ ...field, required: true })),
    ...templateData.optionalFields.map(field => ({ ...field, required: false }))
  ];
  
  // Group fields
  const groupedFields = groupFieldsByCategory(allFields);
  
  // Render field groups
  Object.entries(groupedFields).forEach(([groupName, fields]) => {
    renderFieldGroup(container, groupName, fields);
  });
  
  // Add form validation
  setupFormValidation();
  
  // Check if form is complete
  checkFormCompletion();
}

/**
 * Group fields by category
 */
function groupFieldsByCategory(fields) {
  const groups = {
    '˙,≈1': [],
    '#aH≈1': [],
    '›Í∑¸≈1': [],
    ']n÷': []
  };
  
  fields.forEach(field => {
    // Categorize fields based on their names
    if (['contactName', 'myName', 'opening', 'channel'].includes(field.name)) {
      groups['˙,≈1'].push(field);
    } else if (['ecid', 'customerName', 'contactPerson'].includes(field.name)) {
      groups['#aH≈1'].push(field);
    } else if (['detailedPolicy', 'violationDetails', 'adtype'].includes(field.name)) {
      groups['›Í∑¸≈1'].push(field);
    } else {
      groups[']n÷'].push(field);
    }
  });
  
  // Remove empty groups
  Object.keys(groups).forEach(key => {
    if (groups[key].length === 0) {
      delete groups[key];
    }
  });
  
  return groups;
}

/**
 * Render field group
 */
function renderFieldGroup(container, groupName, fields) {
  const groupHtml = `
    <div class="field-group">
      <div class="field-group-title">
        <i class="fas fa-folder-open"></i>
        ${groupName}
      </div>
      <div class="row" id="group-${groupName}">
        ${fields.map(field => renderFormField(field)).join('')}
      </div>
    </div>
  `;
  
  container.insertAdjacentHTML('beforeend', groupHtml);
}

/**
 * Render individual form field
 */
function renderFormField(field) {
  const fieldId = `field_${field.name}`;
  const requiredAttr = field.required ? 'required' : '';
  const requiredMark = field.required ? '<span class="text-danger">*</span>' : '';
  
  let inputHtml = '';
  
  switch (field.type) {
    case 'select':
      const options = field.options || [];
      const optionsHtml = options.map(opt => 
        `<option value="${opt.value}"${opt.isDefault ? ' selected' : ''}>${opt.label}</option>`
      ).join('');
      
      inputHtml = `
        <select class="form-select" id="${fieldId}" name="${field.name}" ${requiredAttr} onchange="onFieldChange('${field.name}')">
          <option value="">xûWfO`UD</option>
          ${optionsHtml}
        </select>
      `;
      break;
      
    case 'textarea':
      inputHtml = `
        <textarea class="form-control" id="${fieldId}" name="${field.name}" rows="3" 
                  placeholder="${field.placeholder || ''}" ${requiredAttr} 
                  oninput="onFieldChange('${field.name}')"></textarea>
      `;
      break;
      
    case 'checkbox':
      inputHtml = `
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="${fieldId}" name="${field.name}" 
                 onchange="onFieldChange('${field.name}')">
          <label class="form-check-label" for="${fieldId}">
            ${field.label} ${requiredMark}
          </label>
        </div>
      `;
      return `
        <div class="col-md-12 form-group">
          ${inputHtml}
          ${field.helpText ? `<div class="form-text">${field.helpText}</div>` : ''}
          <div class="invalid-feedback"></div>
        </div>
      `;
      
    case 'date':
      inputHtml = `
        <input type="date" class="form-control" id="${fieldId}" name="${field.name}" 
               ${requiredAttr} onchange="onFieldChange('${field.name}')">
      `;
      break;
      
    default: // text, email, tel, etc.
      inputHtml = `
        <input type="${field.inputType || 'text'}" class="form-control" id="${fieldId}" name="${field.name}" 
               placeholder="${field.placeholder || ''}" ${requiredAttr} 
               oninput="onFieldChange('${field.name}')">
      `;
  }
  
  const colClass = ['textarea', 'select'].includes(field.type) ? 'col-md-12' : 'col-md-6';
  
  return `
    <div class="${colClass} form-group">
      ${field.type !== 'checkbox' ? `
        <label for="${fieldId}" class="form-label">
          ${field.label} ${requiredMark}
        </label>
        ${inputHtml}
      ` : inputHtml}
      ${field.helpText ? `<div class="form-text">${field.helpText}</div>` : ''}
      <div class="invalid-feedback"></div>
    </div>
  `;
}

/**
 * Handle field changes
 */
function onFieldChange(fieldName) {
  const field = document.getElementById(`field_${fieldName}`);
  let value;
  
  if (field.type === 'checkbox') {
    value = field.checked;
  } else {
    value = field.value;
  }
  
  AppState.formData[fieldName] = value;
  
  // Apply default values
  if (fieldName === 'myName' && !value && AppState.settings.defaultMyName) {
    field.value = AppState.settings.defaultMyName;
    AppState.formData[fieldName] = AppState.settings.defaultMyName;
  } else if (fieldName === 'opening' && !value && AppState.settings.defaultOpening) {
    field.value = AppState.settings.defaultOpening;
    AppState.formData[fieldName] = AppState.settings.defaultOpening;
  }
  
  // Validate field
  validateField(fieldName);
  
  // Update live preview
  debounce(updateLivePreview, 500)();
  
  // Check form completion
  checkFormCompletion();
  
  // Auto-save if enabled
  if (AppState.settings.enableAutoSave) {
    debounce(saveProgress, 2000)();
  }
}

/**
 * Validate individual field
 */
function validateField(fieldName) {
  const field = document.getElementById(`field_${fieldName}`);
  const feedback = field.parentElement.querySelector('.invalid-feedback');
  
  // Get field definition
  const allFields = [...(AppState.templateData.requiredFields || []), ...(AppState.templateData.optionalFields || [])];
  const fieldDef = allFields.find(f => f.name === fieldName);
  
  if (!fieldDef) return;
  
  let isValid = true;
  let errorMessage = '';
  
  // Required field check
  if (fieldDef.required && (!field.value || field.value.trim() === '')) {
    isValid = false;
    errorMessage = `${fieldDef.label}o≈ÓgY`;
  }
  
  // Format validation
  if (isValid && field.value) {
    if (fieldName === 'ecid' && !/^\d{10}$/.test(field.value)) {
      isValid = false;
      errorMessage = 'ECIDo10AnpWgeõWfO`UD';
    } else if (field.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(field.value)) {
      isValid = false;
      errorMessage = '	πj·¸Î¢…ÏπíeõWfO`UD';
    }
  }
  
  // Update field appearance
  if (isValid) {
    field.classList.remove('is-invalid');
    field.classList.add('is-valid');
    feedback.textContent = '';
  } else {
    field.classList.remove('is-valid');
    field.classList.add('is-invalid');
    feedback.textContent = errorMessage;
  }
  
  return isValid;
}

/**
 * Setup form validation
 */
function setupFormValidation() {
  const form = document.getElementById('templateForm');
  
  form.addEventListener('submit', function(e) {
    e.preventDefault();
    if (validateForm()) {
      nextStep();
    }
  });
}

/**
 * Validate entire form
 */
function validateForm() {
  let isValid = true;
  const requiredFields = AppState.templateData.requiredFields || [];
  
  requiredFields.forEach(fieldDef => {
    if (!validateField(fieldDef.name)) {
      isValid = false;
    }
  });
  
  return isValid;
}

/**
 * Check form completion
 */
function checkFormCompletion() {
  const nextButton = document.getElementById('step4NextButton');
  const requiredFields = AppState.templateData.requiredFields || [];
  
  let isComplete = true;
  
  requiredFields.forEach(fieldDef => {
    const value = AppState.formData[fieldDef.name];
    if (!value || (typeof value === 'string' && value.trim() === '')) {
      isComplete = false;
    }
  });
  
  nextButton.disabled = !isComplete;
}

/**
 * Update live preview
 */
function updateLivePreview() {
  const preview = document.getElementById('livePreview');
  
  if (!AppState.templateData) {
    preview.innerHTML = '∆Û◊Ï¸»L≠º~åfD~[ì';
    return;
  }
  
  try {
    // Simple template processing for preview
    let content = AppState.templateData.preview || AppState.templateData.templateContent || '';
    
    // Replace variables with current form values
    Object.entries(AppState.formData).forEach(([key, value]) => {
      if (value) {
        const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
        content = content.replace(regex, value);
      }
    });
    
    // Highlight remaining placeholders
    content = content.replace(/{{\s*([^}]+)\s*}}/g, '<mark>[$1]</mark>');
    
    preview.innerHTML = content.replace(/\n/g, '<br>');
  } catch (error) {
    console.error('Preview update error:', error);
    preview.innerHTML = '◊Ï”Â¸nÙ∞k1WW~W_';
  }
}

/**
 * Generate final email
 */
async function generateEmail() {
  try {
    const generateButton = document.getElementById('generateButton');
    generateButton.disabled = true;
    generateButton.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>-...';
    
    const response = await apiCall('workflow/generate', {
      workflowId: AppState.workflowId,
      templateId: AppState.templateData.templateId,
      variables: AppState.formData
    });
    
    if (response.success) {
      AppState.generatedContent = response.data;
      displayGeneratedContent(response.data);
      
      // Show generated content, hide step content
      document.getElementById('stepContent').classList.add('d-none');
      document.getElementById('generatedContent').classList.remove('d-none');
      
      // Update progress to 100%
      updateProgress(100);
      
      showSuccess('·¸ÎLc8kUå~W_');
      
      // Play success sound if enabled
      if (AppState.settings.enableSounds) {
        playSuccessSound();
      }
    } else {
      throw new Error(response.error || 'Email generation failed');
    }
  } catch (error) {
    console.error('Email generation error:', error);
    showError('·¸Înk1WW~W_: ' + error.message);
  } finally {
    const generateButton = document.getElementById('generateButton');
    generateButton.disabled = false;
    generateButton.innerHTML = '<i class="fas fa-magic me-2"></i>·¸Î';
  }
}

/**
 * Display generated content
 */
function displayGeneratedContent(data) {
  // Update metadata
  document.getElementById('generatedAt').textContent = new Date(data.metadata.generatedAt).toLocaleString('ja-JP');
  document.getElementById('wordCount').textContent = data.metadata.wordCount;
  document.getElementById('readTime').textContent = data.metadata.estimatedReadTime;
  
  // Display content
  const contentElement = document.getElementById('generatedEmailContent');
  contentElement.textContent = data.generatedContent;
  
  // Make content selectable
  contentElement.style.userSelect = 'text';
  contentElement.style.cursor = 'text';
}

// Navigation functions
function nextStep() {
  if (AppState.currentStep < AppState.totalSteps) {
    hideStep(AppState.currentStep);
    AppState.currentStep++;
    
    // Special handling for step transitions
    if (AppState.currentStep === 3) {
      loadAvailableStatuses();
    } else if (AppState.currentStep === 4) {
      loadTemplate();
    } else if (AppState.currentStep === 5) {
      updateFinalPreview();
    }
    
    showStep(AppState.currentStep);
    updateStepIndicator(AppState.currentStep);
    updateProgress((AppState.currentStep / AppState.totalSteps) * 100);
  }
}

function previousStep() {
  if (AppState.currentStep > 1) {
    hideStep(AppState.currentStep);
    AppState.currentStep--;
    showStep(AppState.currentStep);
    updateStepIndicator(AppState.currentStep);
    updateProgress((AppState.currentStep / AppState.totalSteps) * 100);
  }
}

function showStep(stepNumber) {
  const stepElement = document.getElementById(`step${stepNumber}`);
  if (stepElement) {
    stepElement.classList.remove('d-none');
    stepElement.classList.add('slide-in');
  }
}

function hideStep(stepNumber) {
  const stepElement = document.getElementById(`step${stepNumber}`);
  if (stepElement) {
    stepElement.classList.add('d-none');
    stepElement.classList.remove('slide-in');
  }
}

/**
 * Update step indicator
 */
function updateStepIndicator(currentStep) {
  document.querySelectorAll('.step-item').forEach((item, index) => {
    const stepNum = index + 1;
    const link = item.querySelector('.step-link');
    const icon = item.querySelector('.step-icon');
    
    link.classList.remove('active', 'completed');
    
    if (stepNum < currentStep) {
      link.classList.add('completed');
      icon.className = 'fas fa-check-circle step-icon';
    } else if (stepNum === currentStep) {
      link.classList.add('active');
      icon.className = 'fas fa-circle-dot step-icon';
    } else {
      icon.className = 'fas fa-circle step-icon';
    }
  });
}

/**
 * Update progress bar
 */
function updateProgress(percentage) {
  const progressBar = document.getElementById('progressBar');
  progressBar.style.width = `${percentage}%`;
  progressBar.setAttribute('aria-valuenow', percentage);
}

/**
 * Update final preview
 */
function updateFinalPreview() {
  // Update summary
  document.getElementById('summaryType').textContent = getWorkflowTypeLabel(AppState.workflowType);
  document.getElementById('summaryPolicy').textContent = `${AppState.selectedPolicy.category} > ${AppState.selectedPolicy.subcategory}`;
  document.getElementById('summaryStatus').textContent = getStatusLabel(AppState.selectedStatus);
  document.getElementById('summaryTemplate').textContent = AppState.templateData.templateName || 'N/A';
  document.getElementById('summaryRequired').textContent = (AppState.templateData.requiredFields || []).length;
  
  // Update final preview
  const finalPreview = document.getElementById('finalPreview');
  updateLivePreview();
  finalPreview.innerHTML = document.getElementById('livePreview').innerHTML;
}

/**
 * Get workflow type label
 */
function getWorkflowTypeLabel(typeId) {
  const labels = {
    'misreview': '§È˚',
    'disapproval': 'ç',
    'certification': 'Cert çö',
    'other': ']n÷'
  };
  return labels[typeId] || typeId;
}

/**
 * Get status label
 */
function getStatusLabel(statusValue) {
  const labels = {
    'approved': 'ç',
    'disapproval_with_response': 'çÈ˚ËrKâﬁTBä	',
    'disapproval_inferred': 'ç®,	',
    'need_info': ']n÷Need info	',
    'at_followmail': 'AT/followmail',
    'forced_stop': '76\b'
  };
  return labels[statusValue] || statusValue;
}

// API and utility functions

/**
 * Make API call to Google Apps Script
 */
async function apiCall(action, data = {}) {
  try {
    const payload = {
      action: action,
      ...data
    };
    
    console.log('API Call:', action, data);
    
    const response = await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('ÍØ®π»Lø§‡¢¶»W~W_'));
      }, REQUEST_TIMEOUT);
      
      google.script.run
        .withSuccessHandler((result) => {
          clearTimeout(timeout);
          resolve(result);
        })
        .withFailureHandler((error) => {
          clearTimeout(timeout);
          reject(new Error(error.message || 'µ¸–¸®È¸LzW~W_'));
        })
        .doPost({ postData: { contents: JSON.stringify(payload) } });
    });
    
    console.log('API Response:', response);
    return response;
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}

/**
 * Load user information
 */
async function loadUserInfo() {
  try {
    const userEmail = Session.getActiveUser().getEmail();
    document.getElementById('userInfo').innerHTML = `
      <i class="fas fa-user me-1"></i>
      ${userEmail}
    `;
  } catch (error) {
    console.error('Failed to load user info:', error);
    document.getElementById('userInfo').innerHTML = `
      <i class="fas fa-user me-1"></i>
      Ê¸∂¸
    `;
  }
}

/**
 * Reset workflow
 */
async function resetWorkflow() {
  if (confirm('˛(n\mÖπLYyfÍª√»Uå~YàçWDgYK')) {
    // Reset application state
    AppState.currentStep = 1;
    AppState.workflowType = null;
    AppState.selectedPolicy = { category: null, subcategory: null };
    AppState.selectedStatus = null;
    AppState.templateData = null;
    AppState.formData = {};
    AppState.generatedContent = null;
    
    // Reset UI
    document.getElementById('stepContent').classList.remove('d-none');
    document.getElementById('generatedContent').classList.add('d-none');
    
    // Hide all steps except first
    for (let i = 2; i <= AppState.totalSteps; i++) {
      hideStep(i);
    }
    showStep(1);
    
    // Reset step indicator
    updateStepIndicator(1);
    updateProgress(20);
    
    // Initialize new workflow
    await initializeWorkflow();
    
    showSuccess('∞WDÔ¸Ø’Ì¸íãÀW~W_');
  }
}

/**
 * Edit and regenerate
 */
function editAndRegenerate() {
  // Go back to form step
  document.getElementById('stepContent').classList.remove('d-none');
  document.getElementById('generatedContent').classList.add('d-none');
  
  AppState.currentStep = 4;
  showStep(4);
  updateStepIndicator(4);
  updateProgress(80);
  
  showSuccess('Ë∆‚¸…k;ä~W_');
}

/**
 * Save progress
 */
function saveProgress() {
  try {
    const progressData = {
      workflowId: AppState.workflowId,
      currentStep: AppState.currentStep,
      workflowType: AppState.workflowType,
      selectedPolicy: AppState.selectedPolicy,
      selectedStatus: AppState.selectedStatus,
      formData: AppState.formData,
      timestamp: new Date().toISOString()
    };
    
    localStorage.setItem('policyPlaybookProgress', JSON.stringify(progressData));
    showSuccess('2Wí›XW~W_');
  } catch (error) {
    console.error('Save progress failed:', error);
    showError('2Wn›Xk1WW~W_');
  }
}

/**
 * Clear cache
 */
async function clearCache() {
  if (confirm('≠„√∑ÂíØÍ¢W~YK')) {
    try {
      await apiCall('cache/clear');
      showSuccess('≠„√∑ÂíØÍ¢W~W_');
    } catch (error) {
      console.error('Cache clear failed:', error);
      showError('≠„√∑ÂnØÍ¢k1WW~W_');
    }
  }
}

/**
 * Copy to clipboard
 */
function copyToClipboard() {
  if (!AppState.generatedContent) return;
  
  try {
    navigator.clipboard.writeText(AppState.generatedContent.generatedContent).then(() => {
      showSuccess('ØÍ√◊‹¸…k≥‘¸W~W_');
    }).catch(() => {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = AppState.generatedContent.generatedContent;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      showSuccess('ØÍ√◊‹¸…k≥‘¸W~W_');
    });
  } catch (error) {
    console.error('Copy to clipboard failed:', error);
    showError('≥‘¸k1WW~W_');
  }
}

/**
 * Download as text file
 */
function downloadAsText() {
  if (!AppState.generatedContent) return;
  
  try {
    const content = AppState.generatedContent.generatedContent;
    const blob = new Blob([content], { type: 'text/plain; charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `policy-email-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
    showSuccess('’°§Îí¿¶ÛÌ¸…W~W_');
  } catch (error) {
    console.error('Download failed:', error);
    showError('¿¶ÛÌ¸…k1WW~W_');
  }
}

// Settings functions

/**
 * Show settings modal
 */
function showSettings() {
  // Populate current settings
  document.getElementById('defaultMyName').value = AppState.settings.defaultMyName;
  document.getElementById('defaultOpening').value = AppState.settings.defaultOpening;
  document.getElementById('enableAutoSave').checked = AppState.settings.enableAutoSave;
  document.getElementById('enableSounds').checked = AppState.settings.enableSounds;
  
  // Show modal
  const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
  modal.show();
}

/**
 * Save settings
 */
function saveSettings() {
  try {
    AppState.settings.defaultMyName = document.getElementById('defaultMyName').value;
    AppState.settings.defaultOpening = document.getElementById('defaultOpening').value;
    AppState.settings.enableAutoSave = document.getElementById('enableAutoSave').checked;
    AppState.settings.enableSounds = document.getElementById('enableSounds').checked;
    
    // Save to localStorage
    localStorage.setItem('policyPlaybookSettings', JSON.stringify(AppState.settings));
    
    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
    modal.hide();
    
    showSuccess('-öí›XW~W_');
  } catch (error) {
    console.error('Save settings failed:', error);
    showError('-ön›Xk1WW~W_');
  }
}

/**
 * Load settings
 */
async function loadSettings() {
  try {
    const saved = localStorage.getItem('policyPlaybookSettings');
    if (saved) {
      AppState.settings = { ...AppState.settings, ...JSON.parse(saved) };
    }
  } catch (error) {
    console.error('Load settings failed:', error);
  }
}

// UI utility functions

/**
 * Show loading state
 */
function showLoading() {
  document.getElementById('loadingState').classList.remove('d-none');
}

/**
 * Hide loading state
 */
function hideLoading() {
  document.getElementById('loadingState').classList.add('d-none');
}

/**
 * Show step content
 */
function showStepContent() {
  document.getElementById('stepContent').classList.remove('d-none');
}

/**
 * Show form loading
 */
function showFormLoading() {
  const container = document.getElementById('formFields');
  container.classList.add('loading');
}

/**
 * Hide form loading
 */
function hideFormLoading() {
  const container = document.getElementById('formFields');
  container.classList.remove('loading');
}

/**
 * Show error message
 */
function showError(message) {
  const errorState = document.getElementById('errorState');
  const errorMessage = document.getElementById('errorMessage');
  
  errorMessage.textContent = message;
  errorState.classList.remove('d-none');
  
  // Also show error toast
  showErrorToast(message);
}

/**
 * Hide error message
 */
function hideError() {
  const errorState = document.getElementById('errorState');
  errorState.classList.add('d-none');
}

/**
 * Show success toast
 */
function showSuccess(message) {
  showSuccessToast(message);
}

/**
 * Show success toast
 */
function showSuccessToast(message) {
  const toast = document.getElementById('successToast');
  const toastBody = toast.querySelector('.toast-body');
  
  toastBody.textContent = message;
  
  const bsToast = new bootstrap.Toast(toast);
  bsToast.show();
}

/**
 * Show error toast
 */
function showErrorToast(message) {
  const toast = document.getElementById('errorToast');
  const toastBody = toast.querySelector('.toast-body');
  
  toastBody.textContent = message;
  
  const bsToast = new bootstrap.Toast(toast);
  bsToast.show();
}

/**
 * Play success sound
 */
function playSuccessSound() {
  try {
    // Simple success sound using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
    oscillator.frequency.setValueAtTime(1200, audioContext.currentTime + 0.2);
    
    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.3);
  } catch (error) {
    console.warn('Could not play success sound:', error);
  }
}

// Utility functions

/**
 * Debounce function
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle function
 */
function throttle(func, wait) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, wait);
    }
  }
}

// Export functions for testing (if in development mode)
if (typeof window !== 'undefined') {
  window.PolicyPlayBook = {
    AppState,
    initializeApp,
    selectWorkflowType,
    selectStatus,
    generateEmail,
    resetWorkflow,
    apiCall
  };
}
</script>